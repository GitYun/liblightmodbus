#include <iostream>
#include <iomanip>
#include <string>
#include <sstream>
#include <vector>
#include <cassert>
#include <cctype>
#include <algorithm>
using namespace std::string_literals;

#define LIGHTMODBUS_FULL
#define LIGHTMODBUS_DEBUG
#define LIGHTMODBUS_IMPL
#include <lightmodbus/lightmodbus.h>

enum modbus_flavor
{
	MODBUS_PDU,
	MODBUS_RTU,
	MODBUS_TCP
};

struct modbus_exception_info
{
	uint8_t address;
	uint8_t function;
	ModbusExceptionCode code;
};

uint16_t regs[65536];
uint8_t coils[65536];
std::vector<ModbusDataCallbackArgs> received_data;
std::vector<uint8_t> request_data;
std::vector<uint8_t> response_data;
modbus_flavor modbus_mode = MODBUS_PDU;
ModbusMaster master;
ModbusErrorInfo master_error;
ModbusSlave slave;
ModbusErrorInfo slave_error;
int transaction_id = 0;

/*
	Data callback for printing all incoming data
*/
ModbusError dataCallback(ModbusMaster *master, const ModbusDataCallbackArgs *args)
{
	received_data.push_back(*args);

	// Always return MODBUS_OK
	return MODBUS_OK;
}

/*
	Exception callback for printing out exceptions on master side
*/
ModbusError masterExceptionCallback(ModbusMaster *master, uint8_t address, uint8_t function, ModbusExceptionCode code)
{
	printf("Received slave %d exception %s (function %d)\n", address, modbusExceptionCodeStr(code), function);

	// Always return MODBUS_OK
	return MODBUS_OK;
}

/*
	Commands:
		- setmode pdu/rtu/tcp
		- build <params> - builds a request
		- dumpregs - dumps slave's registers
		- dumpreq - dumps the request frame stored by master
		- dumpresp - dumps the response frame stored by slave
		- parsemaster - parses frame generated by master
		- parseslave - parses frame generated by slave
		- dumpslave
		- dumpmaster
		- setreq <hex data>
		- setresp <hex data>
		- parsereq <hex data>
		- parseresp <hex data>
*/



template <typename T>
std::string serialize_data(const T *data, int length)
{
	std::stringstream ss;
	ss << "[";

	for (int i = 0; i < length; i++)
	{
		ss << "0x" << std::hex << std::setfill('0') << std::fixed << std::setw(sizeof(T) * 2) << static_cast<int>(data[i]);
		if (i != length - 1)
			ss << ", ";
	}
	ss << "]";
	return ss.str();
}

template <typename T>
std::string serialize_data(const std::vector<T> &vec)
{
	return serialize_data(vec.data(), static_cast<int>(vec.size()));
}

std::string error_info_str(ModbusErrorInfo info)
{
	if (modbusIsOk(info))
		return "OK";
	else
	{
		return std::string{modbusErrorSourceStr(modbusGetErrorSource(info))} 
			+ "("
			+ modbusErrorStr(modbusGetErrorCode(info))
			+ ")";
	}
}

void build_request(std::istringstream &ss)
{
	int fun, address, index, count, value;
	ss >> fun >> address;

	request_data.clear();

	switch (modbus_mode)
	{
		case MODBUS_PDU: master_error = modbusBeginRequestPDU(&master); break;
		case MODBUS_RTU: master_error = modbusBeginRequestRTU(&master); break;
		case MODBUS_TCP: master_error = modbusBeginRequestTCP(&master); break;
	}

	if (!modbusIsOk(master_error))
		return;

	switch (fun)
	{
		case 1:
			ss >> index >> count;
			master_error = modbusBuildRequest01(&master, index, count);
			break;

		case 2:
			ss >> index >> count;
			master_error = modbusBuildRequest02(&master, index, count);
			break;

		case 3:
			ss >> index >> count;
			master_error = modbusBuildRequest03(&master, index, count);
			break;

		case 4:
			ss >> index >> count;
			master_error = modbusBuildRequest04(&master, index, count);
			break;

		case 5:
			ss >> index >> value;
			master_error = modbusBuildRequest05(&master, index, value);
			break;

		case 6:
			ss >> index >> value;
			master_error = modbusBuildRequest06(&master, index, value);
			break;

		case 15:
		{
			ss >> index >> count;
			std::vector<uint8_t> data((count + 7) / 8);
			for (int i = 0; i < count; i++)
			{
				int tmp;
				ss >> tmp;
				modbusMaskWrite(data.data(), i, tmp);
			}
			master_error = modbusBuildRequest15(&master, index, count, data.data());
			break;
		}

		case 16:
		{
			ss >> index >> count;
			std::vector<uint16_t> data(count);
			for (int i = 0; i < count; i++)
				ss >> data[i];
			master_error = modbusBuildRequest16(&master, index, count, data.data());
			break;
		}

		case 22:
		{
			int andmask, ormask;
			ss >> index >> andmask >> ormask;
			master_error = modbusBuildRequest22(&master, index, andmask, ormask);
			break;
		}

		default:
			throw std::runtime_error{"building failed - bad function"};
			break;

	}

	if (!modbusIsOk(master_error))
		return;

	switch (modbus_mode)
	{
		case MODBUS_PDU: master_error = modbusEndRequestPDU(&master); break;
		case MODBUS_RTU: master_error = modbusEndRequestRTU(&master, address); break;
		case MODBUS_TCP: master_error = modbusEndRequestTCP(&master, transaction_id++, address); break;
	}

	if (!modbusIsOk(master_error))
		return;

	const uint8_t *ptr = modbusMasterGetRequest(&master);
	int size = modbusMasterGetRequestLength(&master);
	request_data = std::vector<uint8_t>(ptr, ptr + size);
	modbusMasterFreeRequest(&master);
}

void dump_request()
{
	std::cout << serialize_data(request_data) << "," << std::endl;
}

void dump_master()
{
	std::cout << "{\"error\": \"" << error_info_str(master_error) << "\"}," << std::endl;
}

void set_mode(std::istringstream &ss)
{
	std::string m;
	ss >> m;
	if (m == "pdu")
		modbus_mode = MODBUS_PDU;
	else if (m == "rtu")
		modbus_mode = MODBUS_RTU;
	else if (m == "tcp")
		modbus_mode = MODBUS_TCP;
	else
		throw std::runtime_error{"invalid Modbus mode "s + m};
}


void parse_line(std::string line)
{
	// Remove leading whitespace
	line.erase(line.begin(), std::find_if(line.begin(), line.end(), [](char c) {
		return !std::isspace(c);
	}));

	// Ignore empty lines and comments
	if (line.empty() || line[0] == '#') return;

	std::istringstream ss(line);
	std::string cmd;
	ss >> cmd;

	if (cmd == "build")
		build_request(ss);
	else if (cmd == "master")
		dump_master();
	else if (cmd == "request")
		dump_request();
	else if (cmd == "setmode")
		set_mode(ss);
	else
		throw std::runtime_error{"invalid command"};

}


int main(int argc, char *argv[])
{
	master_error = modbusMasterInit(
		&master,
		dataCallback,
		masterExceptionCallback,
		modbusMasterDefaultAllocator,
		modbusMasterDefaultFunctions,
		modbusMasterDefaultFunctionCount
	);
	assert(modbusIsOk(master_error) && "master init failed");


	std::string line;
	while (std::getline(std::cin, line))
		parse_line(line);

	modbusMasterDestroy(&master);
}