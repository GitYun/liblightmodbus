/**
\mainpage liblightmodbus - a lightweight, header-only, cross-platform Modbus RTU/TCP library

This is the reference manual for the version v3.0 liblightmodbus library.

If you're looking for the docs for older versions, please visit: https://jacajack.github.io/liblightmodbus/olddocs/

\section about About this release
Version v3.0 brings the most changes in the history of liblightmodbus. Majority 
of the source code has been rewritten from scratch. The library is now header-only,
which makes it much easier to compile on different platforms and introduces support
for Modbus TCP. 

All this changes resulted in a significant binary size reduction (around 2x) and
more maintainable and flexible code.

\section getting-started Getting started
 - \ref building
 - \ref slave
 - \ref master
 - \ref error-handling
 - \ref allocators
 - \ref examples
 - \ref porting

\page building Building and integrating liblightmodbus

Since the version v3.0, liblightmodbus is a header-only library. This decision was
made due to large number of questions and problems regarding compilation on different platforms.
As it turns out, CMake doesn't go very well with embedded projects.

In order to integrate liblightmodbus with your project you need to add
`liblightmodbus/include` to you include paths. If you're using CMake you might 
do that automatically by including `lightmodbus` package.

In your source code you should be using `#include <lightmodbus/lightmodbus.h>` to include the library.
The library can be configured by defining certain macros before including that file:
| Macro | Description |
|-------|-------------|
|`LIGHTMODBUS_IMPL`|Include implementation|
|`LIGHTMODBUS_BIG_ENDIAN`|Use when your platform uses big endian byte order|
|`LIGHTMODBUS_SLAVE`|Includes slave part of the library|
|`LIGHTMODBUS_MASTER`|Includes master part of the library|
|`LIGHTMODBUS_FULL`|Includes both slave and master modules and all of their functions|
|`LIGHTMODBUS_DEBUG`|Includes some debugging utilites|
|`LIGHTMODBUS_MASTER_OMIT_REQUEST_CRC`|Omits request CRC calculation for request on master side|

Specific master/slave functions can be included by defining macros like `LIGHTMODBUS_F01M` or `LIGHTMODBUS_F22S`.

Each time `lightmodbus.h` is included, the set of defined configuration macros must be the same
(except from `LIGHTMODBUS_IMPL` which should only be used **once**).

Moreover, it's very important that you include implementation of the library functions (`LIGHTMODBUS_IMPL`) in **exactly one** place in your codebase. It may be a good idea to create a source file dedicated specifically for
including implementation of liblightmodbus. For instance, you may want to create `lightmodbus-impl.c` containing:
~~~c
#include "my-consistent-liblightmodbus-config-macros.h"
#define LIGHTMODBUS_IMPL
#include <lightmodbus/lightmodbus.h>
~~~

\section embedded Embedded platforms

Since v3.0 building liblightmodbus on embedded platforms is no different 
from building it on your PC. You're only required to add the header files to your project.

\note Tip: Be sure to enable linking time optimizations (`-flto`) when building your project
	to further reduce the size of your binary.

\subsection ESP-IDF

\todo Complete this section

\page slave Slave device

In order to use slave side functions, make sure to define `LIGHTMODBUS_SLAVE` macro before
including the library. Please also see \ref building for more information.

\section slave-init Slave initialization
Slave device state is represented by ModbusSlave structure. It must be initialized with modbusSlaveInit()
before it is used:
~~~c
ModbusSlave slave;
ModbusErrorInfo err;
err = modbusSlaveInit(
	&slave,          
	1,                               // Address of the slave
	modbusSlaveDefaultAllocator,     // Memory allocator for ModbusSlave
	myRegisterCallback,              // Callback for register operations
	myExceptionCallback,             // Callback for handling slave exceptions (optional)
	modbusSlaveDefaultFunctions,     // Set of supported functions
	modbusSlaveDefaultFunctionCount  // Number of supported functions
	);

// Check for errors
assert(modbusIsOk(err) && "modbusSlaveInit() failed"); 
~~~

ModbusSlave contains an internal buffer the response data. This buffer is allocated by the allocator passed to modbusSlaveInit().
modbusSlaveDefaultAllocator is a default allocator that uses malloc() and free() functions.
You may write your own, more sophisticated allocators if you wish - please see \ref allocators for more details.

In this code `myRegisterCallback` is a name of a callback function that will be called for every register operation.
In previous this versions of the library this functionality was optionally available as `LIGHTMODBUS_REGISTER_CALLBACK`.
Now, all register operations are performed using callbacks.

`myExceptionCallback` is a name of a callback function that will be called every time slave
reports an exception to the master. To disable this functionality, pass NULL as the callback.

The set of functions supported by the slave is determined by the 6th function argument - in this case
`modbusSlaveDefaultFunctions`. This argument is a pointer to an array of ModbusSlaveFunctionHandler
structures which associate function codes with callbacks. Lifetime of this array must not be shorter
than thelifetime of the slave. The length of this array should be provided as the last argument.

\section slave-register-callback Register callback
An exapmple implementation of a register callback operating on registers stored in an array:
~~~c
#define REG_COUNT 16
static uint16_t registers[REG_COUNT];
static uint16_t inputRegisters[REG_COUNT];
static uint8_t coils[REG_COUNT / 8]; // Each coil corresponds to one bit
static uint8_t discreteInputs[REG_COUNT / 8]; // Each input corresponds to one bit

ModbusError myRegisterCallback(
	ModbusSlave *status,
	const ModbusRegisterCallbackArgs *args,
	uint16_t *result)
{
	// Respond to read/write access queries
	if (args->query == MODBUS_REGQ_R_CHECK || args->query == MODBUS_REGQ_W_CHECK)
	{
		// If result of a read/write access query is not 0,
		// an exception is reported by the slave
		*result = args->id < REG_COUNT ? MODBUS_EXCEP_NONE : MODBUS_EXCEP_ILLEGAL_ADDRESS;
	}
	else if (args->query == MODBUS_REGQ_R) // Read registers
	{
		switch (args->type)
		{
			case MODBUS_HOLDING_REGISTER: *result = registers[args->id]; break;
			case MODBUS_INPUT_REGISTER:   *result = inputRegsiters[args->id]; break;
			case MODBUS_COIL:             *result = modbusMaskRead(coils, args->id); break;
			case MODBUS_DISCRETE_INPUT:   *result = modbusMaskRead(discreteInputs, args->id); break;
			default: return MODBUS_ERROR_OTHER;
		}
	}
	else if (args->query == MODBUS_REGQ_W) // Write registers
	{
		switch (args->type)
		{
			case MODBUS_HOLDING_REGISTER: registers[args->id] = args->value; break;
			case MODBUS_COIL:             modbusMaskWrite(coils, args->id, args->value); break;
			default: return MODBUS_ERROR_OTHER;
		}
	}
	else
		return MODBUS_ERROR_OTHER;

	// Return MODBUS_OK on success
	return MODBUS_OK;
}
~~~

\section slave-exception-callback Slave exception callback

\note Returning error values different than MODBUS_OK from the callback will result in
	MODBUS_EXCEP_SLAVE_FAILURE exception being reported to the master. 

\todo Complete this section

\section slave-requests Request processing

\note Return values from this callback are ignored. This functionality,
	however, should not be relied upon and may be subject to change in future releases.

\todo Complete this section

After successful initialization of the slave device, it's ready to accept requests from the master:
~~~c
// For Modbus RTU
ModbusErrorInfo err;
err = modbusParseRequestRTU(&slave, buffer, length);

// Handle 'serious' errors such as memory allocation problems
if (modbusGetGeneralError(&slave))
	handleSlaveError(err);

// Handle errors related to the structure of the request frame
// for example invalid CRC
if (modbusGetRequestError(&slave))
	handleRequesterrors(err);

// If the function did not return an error, the response is ready to be sent
// to master. The response frame is located inside ModbusSlave at ModbusSlave::response::data
// and is ModbusSlave::response::length bytes long. Beware that response frame can be empty
// in some cases!
if (modbusIsOk(err))
	sendToMaster(slave.response.data, slave.response.length);

// Optionally, the response buffer can be freed now
modbusSlaveFreeResponse(&slave);
~~~

\section slave-cleanup Slave cleanup
In order to destroy the ModbusSlave structure, simply call modbusSlaveDestroy():
~~~c
modbusSlaveDestroy(&slave);
~~~

\page master Master

In order to use master side functions, make sure to define `LIGHTMODBUS_MASTER` macro before
including the library. Please also see \ref building for more information.

\section master-init Master initialization
Master device state is represented by ModbusMaster structure. It must be initialized with modbusMasterInit()
before it is used:
~~~c
ModbusMaster master;
ModbusErrorInfo err;
err = modbusMasterInit(
	&master,          
	modbusMasterDefaultAllocator,    // Memory allocator for ModbusMaster
	myDataCallback,                  // Callback for handling incoming data
	myExceptionCallback,             // Optional slave exception callback
	modbusMasterDefaultFunctions,    // Set of supported functions
	modbusMasterDefaultFunctionCount // Number of supported functions
	);

// Check for errors
assert(modbusIsOk(err) && "modbusMasterInit() failed"); 
~~~

Similarly to slave, master has its own memory allocator - please refer to \ref allocators for more information.

Additionally, master has two callbacks - data callback and exception callback. The first is
used for processing all register data incoming to master, the latter for handling exceptions
reported by the slave. These callback are described in more detail in \ref master-data-callback and
\ref master-exception-callback.

The 5th argument determines the set of functions supported by the master device. It should be
a pointer to an array of ModbusMasterFunctionHandler structures which associate function codes
with callbacks. The lifetime of this array must not be shorter than the lifetime of the master.
The last argument should contain length of this array.

\section master-data-callback Data callback

\note Return values from this callback are ignored. This functionality,
	however, should not be relied upon and may be subject to change in future releases.

\todo Complete this section

\section master-exception-callback Exception callback

\note Return values from this callback are ignored. This functionality,
	however, should not be relied upon and may be subject to change in future releases.

\todo Complete this section

\section master-requests Building requests

Master side of the library provides a set of functions for building requests. They are named
according to the pattern `modbusMasterBuildRequest*()`. Where `*` is code of the function followed
by the Modbus request format to be generated (PDU, RTU or TCP).

The functions without PDU, RTU or TCP at the end of their name are generic functions 
responsible for building the request frame and must only be used in between calls to
`modbusBeginRequest*()` and `modbusEndRequest*()`.

|Function code|Description|Functions|
|-------------|-----------|---------|
|01|Read multiple coils|modbusBuildRequest01()<br>modbusBuildRequest01PDU()<br>modbusBuildRequest01RTU()<br>modbusBuildRequest01TCP()|
|02|Read multiple discrete inputs|modbusBuildRequest02()<br>modbusBuildRequest02PDU()<br>modbusBuildRequest02RTU()<br>modbusBuildRequest02TCP()|
|03|Read multiple holding registers|modbusBuildRequest03()<br>modbusBuildRequest03PDU()<br>modbusBuildRequest03RTU()<br>modbusBuildRequest03TCP()|
|04|Read multiple input registers|modbusBuildRequest04()<br>modbusBuildRequest04PDU()<br>modbusBuildRequest04RTU()<br>modbusBuildRequest04TCP()|
|05|Write a single coil|modbusBuildRequest05()<br>modbusBuildRequest05PDU()<br>modbusBuildRequest05RTU()<br>modbusBuildRequest05TCP()|
|06|Write a single holding register|modbusBuildRequest06()<br>modbusBuildRequest06PDU()<br>modbusBuildRequest06RTU()<br>modbusBuildRequest06TCP()|
|15|Write multiple coils|modbusBuildRequest15()<br>modbusBuildRequest15PDU()<br>modbusBuildRequest15RTU()<br>modbusBuildRequest15TCP()|
|16|Write multiple holding registers|modbusBuildRequest16()<br>modbusBuildRequest16PDU()<br>modbusBuildRequest16RTU()<br>modbusBuildRequest16TCP()|
|22|Mask write register|modbusBuildRequest22()<br>modbusBuildRequest22PDU()<br>modbusBuildRequest22RTU()<br>modbusBuildRequest22TCP()|

Please see \ref master_func.impl.h for more details.

For instance, a request to read holding register 17 from slave with id 1 can be built using:
~~~c
// For Modbus RTU
ModbusErrorInfo err;
err = modbusMasterBuildRequest03RTU(&master, 1, 17, 1);
assert(modbusIsOk(err) && "modbusMasterBuildRequest03RTU() failed");
~~~

If the request has been built successfully, it's avaiable at `master.request.data` 
and has length of `master.request.length` bytes and can be sent to the slave.

\section master-response Processing responses

After obtaining the response from the slave, it's time to process it. In order to do that
one of the `modbusParseResponse*()` functions can be used:
~~~c
// For Modbus RTU
ModbusErrorInfo err;
err = modbusParseResponseRTU(
	&master,
	master.request.data,
	master.request.length,
	slaveResponseData,
	slaveResponseLength);

// Handle serious errors
if (modbusGetGeneralError(err))
	handleMasterError(err);

// Handle errors relate to the structure of the request frame
if (modbusGetRequestError(err))
	handleRequestError(err);

// Handle errors related to the structure of the response frame
if (modbusGetResponseError(err))
	handleResponseError(err);

// Optionally free the request frame
modbusMasterFreeRequest(&master);
~~~

\section master-cleanup Master cleanup

\todo Complete this section

\page error-handling Error handling
Liblightmodbus v3.0 introduces a new type for error handling - \ref ModbusErrorInfo - returned by majority
of the library functions. This new type allows to store both error type and its source (whether it was caused
by an invalid request/response frame or by an actual library error).

Previously, you would check for errors like this:
~~~c
ModbusError err = modbusDoSomething();
if (err != MODBUS_OK)
	doSomething();
~~~

In the new version, it's a bit more sophisticated:
~~~c
ModbusErrorInfo err = modbusDoSomething();

// We can check if any error happened at all
if (!modbusIsOk(err))
	doSomething();

// We can check if the library reported any general errors
// Those usually mean that the user provided an invalid argument
// or something had failed internally.
if (modbusGetGeneralError(err) != MODBUS_OK)
	handleSeriousError();

// We can check if the request frame contained an error
if (modbusGetRequestError(err) != MODBUS_OK)
	handleRequestError();

// We can also check if the response frame contained an error
if (modbusGetResponseError(err) != MODBUS_OK)
	handleResponseError();
~~~

`modbusGetGeneralError()`, `modbusGetRequestError()` and `modbusGetResponseError()` return
a `ModbusError` enum value which can be easily handled with a switch statement.

\warning You should **not** be accessing the fields of `ModbusErrorInfo` directly.
	The internals of this struct are subject to change in future versions, and
	for this exact reason the modbusIsOk() etc. functions exist.

\page allocators Custom allocators

Liblightmodbus allows users to define their custom functions for memory management.
This functionality is provided with mainly embedded systems in mind.

The user defined allocator is a function compatible with ModbusSlaveAllocator or ModbusMasterAllocator pointer types.

User-defined allocators must meet following requirements:
 - When `size` is 0, the memory pointed to by `*ptr` must be freed. `*ptr`
	shall then be set to `NULL`.
 - When `size` is not 0, `*ptr` should be set to point to a memory block of
	at least `size` bytes. If such block cannot be allocated, the allocator must
	return \ref MODBUS_ERROR_ALLOC and free memory block pointed to by current
	`*ptr` value. In such case `*ptr` shall be set to `NULL`.

However, certain guarantees are made by the library:
 - All allocation requests originating from a **single** ModbusMaster or
	ModbusSlave instance with identical `purpose` argument are assumed
	to refer to the same buffer. **This allows for static memory allocation
	if the allocator can distinguish between different ModbusMaster and
	ModbusSlave instances issuing the allocation requests.**

\section static-mem Static memory allocation

An example of a custom "allocator" relying only on statically allocated memory:
~~~c
// !!! This only works if the allocator is used exclusively by a single instance of ModbusMaster and ModbusSlave !!!
LIGHTMODBUS_WARN_UNUSED ModbusError modbusStaticAllocator(uint8_t **ptr, uint16_t size, ModbusBufferPurpose purpose)
{
	static uint8_t request[256];
	static uint8_t response[256];

	if (!size)
	{
		// Pretend we're freeing the buffer
		*ptr = NULL;
		return MODBUS_OK;
	}
	else
	{
		if (size > 256)
		{
			// Requested size is too big, return allocation error
			*ptr = NULL;
			return MODBUS_ERROR_ALLOC;
		}
		else
		{
			// Return a pointer to one of the static buffers depending 
			// on the declared purpose of the buffer
			*ptr = purpose == MODBUS_SLAVE_RESPONSE_BUFFER ? response : request;
			return MODBUS_OK;
		}
	}
}

// Wrapper used by slave
LIGHTMODBUS_WARN_UNUSED ModbusError modbusSlaveStaticAllocator(ModbusSlave *status, uint8_t **ptr, uint16_t size, ModbusBufferPurpose purpose)
{
	return modbusStaticAllocator(ptr, size, purpose);
}

// Wrapper used by master
LIGHTMODBUS_WARN_UNUSED ModbusError modbusMasterStaticAllocator(ModbusMaster *status, uint8_t **ptr, uint16_t size, ModbusBufferPurpose purpose)
{
	return modbusStaticAllocator(ptr, size, purpose);
}
~~~

One could also implement the buffers in `modbusSlaveStaticAllocator()` and `modbusMasterStaticAllocator()` and
distiguish between `ModbusSlave` and `ModbusMaster` instances based on the `status` argument.

\page examples Examples

Examples can be found in the [examples](https://github.com/Jacajack/liblightmodbus/tree/master/examples) directory.

\page porting Porting code from v2.0 to v3.0

The table below presents a brief overview of changes that need to be applied to existing code 
before upgrading to v3.0.

|Task|Changes|
|----|--------|
|Slave init|Update call to `modbusSlaveInit()` according to \ref slave-init|
|Master init|Update call to `modbusMasterInit()` according to \ref master-init|
|Slave cleanup|Rename `modbusSlaveEnd()` to `modbusSlaveDestroy()`|
|Master cleanup|Rename `modbusMasterEnd()` to `modbusMasterDestroy()`|
|Error handling|Use `modbusIsOk()` and `modbusGetGeneralError()`. See \ref error-handling|
|Parsing requests|Use `modbusParseRequestRTU()` instead of `modbusParseRequest()`. Provide the frame as an argument.|
|Register callback|Slave register callback now takes arguments in a struct. See \ref slave-register-callback|
|Register/coil arrays|Write a register callback accesing your own array instead. See \ref slave-register-callback|
|Accessing slave's response|Use modbusSlaveGetResponse() and modbusSlaveGetResponseLength() instead of accessing directly accessing the fields in ModbusSlave|
|Building requests|Use `modbusBuildRequest*RTU()` instead of `modbusBuildRequest*()`|
|Accessing master's request|Use modbusMasterGetRequest() and modbusMasterGetRequestLength() instead of accessing directly accessing the fields in ModbusSlave|
|Parsing responses|Use `modbusParseResponseRTU()` instead of `modbusParseResponse()`. Provide both request and response frames as arguments|
|Receiving data|Implement a data callback to receive the data on the master end - see \ref master-data-callback|
|Endiannes operations|Use modbusRLE(), modbusRBE(), modbusWLE() and modbusWBE() instead|
|Mask read/write|modbusMaskRead() and modbusMaskWrite() no longer provide bound checking|
|Static memory allocation|Implement a custom static memory allocator - see \ref static-mem|

\cond DOXYGEN_EXCLUDE
\section endiannnes Endianness operations
`modbusSwapEndian()` and `modbusMatchEndian()` were dropped in favor of less ambiguous and safe
functions for reading 16-bit integer words:
 - `modbusRLE()` - read a 16-bit little-endian word
 - `modbusRBE()` - read a 16-bit big-endian word
 - `modbusWLE()` - write a 16-bit little-endian word
 - `modbusWBE()` - write a 16-bit big-endian word

Conveniently, pointers provided to those functions don't need to be aligned, because
reading is done byte-after-byte manner for safety and portability (`__attribute__((packed))` is not so great. It's completely useless on XC16 compilers).
\endcond

*/
