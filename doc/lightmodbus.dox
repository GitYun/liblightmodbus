/**
\mainpage liblightmodbus - a lightweight, header-only, cross-platform Modbus RTU/TCP library

This is the reference manual for the version v3.0 liblightmodbus library.

If you're looking for the docs for older versions, please visit: https://jacajack.github.io/liblightmodbus/olddocs/

\section about About this release
Version v3.0 brings the most changes in the history of liblightmodbus. Majority 
of the source code has been rewritten from scratch. The library is now header-only,
which makes it much easier to compile on different platforms and introduces support
for Modbus TCP. 

All this changes resulted in a significant binary size reduction (around 2x) and
more maintainable and flexible code.

\section getting-started Getting started
 - \ref building
 - \ref slave
 - \ref master
 - \ref error-handling
 - \ref allocators
 - \ref examples
 - \ref porting

\page building Building and integrating liblightmodbus

Since the version v3.0, liblightmodbus is a header-only library. This decision was
made due to large number of questions and problems regarding compilation on different platforms.
As it turns out, CMake doesn't go very well with embedded projects.

In order to integrate liblightmodbus with your project you need to add
`liblightmodbus/include` to you include paths. If you're using CMake you might 
do that automatically by including `lightmodbus` package.

In your source code you should be using `#include <lightmodbus/lightmodbus.h>` to include the library.
The library can be configured by defining certain macros before including that file:
| Macro | Description |
|-------|-------------|
|`LIGHTMODBUS_IMPL`|Include implementation|
|`LIGHTMODBUS_BIG_ENDIAN`|Use when your platform uses big endian byte order|
|`LIGHTMODBUS_SLAVE`|Includes slave part of the library|
|`LIGHTMODBUS_MASTER`|Includes master part of the library|
|`LIGHTMODBUS_FULL`|Includes both slave and master modules and all of their functions|
|`LIGHTMODBUS_DEBUG`|Includes some debugging utilites|
|`LIGHTMODBUS_MASTER_OMIT_REQUEST_CRC`|Omits request CRC calculation for request on master side|

Specific master/slave functions can be included by defining macros like `LIGHTMODBUS_F01M` or `LIGHTMODBUS_F22S`.

Each time `lightmodbus.h` is included, the set of defined configuration macros must be the same
(except from `LIGHTMODBUS_IMPL` which should only be used **once**).

Moreover, it's very important that you include implementation of the library functions (`LIGHTMODBUS_IMPL`) in **exactly one** place in your codebase. It may be a good idea to create a source file dedicated specifically for
including implementation of liblightmodbus. For instance, you may want to create `lightmodbus-impl.c` containing:
~~~c
#include "my-consistent-liblightmodbus-config-macros.h"
#define LIGHTMODBUS_IMPL
#include <lightmodbus/lightmodbus.h>
~~~

\section embedded Embedded platforms

Since v3.0 building liblightmodbus on embedded platforms is no different 
from building it on your PC. You're only required to add the header files to your project.

\note Tip: Be sure to enable linking time optimizations (`-flto`) when building your project
	to further reduce the size of your binary.

\subsection ESP-IDF

\todo Complete this section

\page slave Slave device

In order to use slave side functions, make sure to define `LIGHTMODBUS_SLAVE` macro before
including the library. Please also see \ref building for more information.

\section slave-init Slave initialization
Slave device state is represented by ModbusSlave structure. It must be initialized with modbusSlaveInit()
before it is used:
~~~c
ModbusSlave slave;
ModbusErrorInfo err;
err = modbusSlaveInit(
	&slave,          
	1,                               // Address of the slave
	myRegisterCallback,              // Callback for register operations
	myExceptionCallback,             // Callback for handling slave exceptions (optional)
	modbusSlaveDefaultAllocator,     // Memory allocator for ModbusSlave
	modbusSlaveDefaultFunctions,     // Set of supported functions
	modbusSlaveDefaultFunctionCount  // Number of supported functions
	);

// Check for errors
assert(modbusIsOk(err) && "modbusSlaveInit() failed"); 
~~~

ModbusSlave contains an internal buffer the response data. This buffer is allocated by the allocator passed to `modbusSlaveInit()`.
modbusSlaveDefaultAllocator is a default allocator that uses malloc() and free() functions.
You may write your own, more sophisticated allocators if you wish - please see \ref allocators for more details.

In this code `myRegisterCallback` is a name of a callback function that will be called for every register operation.
In previous this versions of the library this functionality was optionally available as `LIGHTMODBUS_REGISTER_CALLBACK`.
Now, all register operations are performed using callbacks.

`myExceptionCallback` is a name of a callback function that will be called every time slave
reports an exception to the master. To disable this functionality, pass NULL as the callback.

The set of functions supported by the slave is determined by the 6th function argument - in this case
`modbusSlaveDefaultFunctions`. This argument is a pointer to an array of ModbusSlaveFunctionHandler
structures which associate function codes with callbacks. Lifetime of this array must not be shorter
than thelifetime of the slave. The length of this array should be provided as the last argument.

\section slave-register-callback Register callback
The register callback is a function matching `ModbusRegisterCallback` used to read and write registers.

provide register values for the Master.


\subsection slave-register-callback-access R/W access check queries
When `ModbusRegisterCallbackArgs::query` is either \ref MODBUS_REGQ_R_CHECK or \ref MODBUS_REGQ_W_CHECK an access query is being made to the callback function.

The \ref MODBUS_REGQ_R_CHECK value of `ModbusRegisterCallbackArgs::query` means that read access is requested and \ref MODBUS_REGQ_W_CHECK means that write access is requested.

The type of accessed register is provided to the function in `ModbusRegisterCallbackArgs::type`. The index of the register is stored in `ModbusRegisterCallbackArgs::index` and the ID of the function requesting access is available in `ModbusRegisterCallbackArgs::function`.

The value stored in `ModbusRegisterCallbackArgs::value` during a write access check contains the value of the register that will be written in a subsequent write request. In case of read requests the value stored in this variable may not be used.

In order to respond to an access query, the function must return a value via the `result` pointer argument. This value is treated as the exception code that the slave will report to the master. In order to allow access to a certain register \ref MODBUS_EXCEP_NONE should be returned. Otherwise, an exception code such as \ref MODBUS_EXCEP_SLAVE_FAILURE should be returned.

The return value of the register callback is checked by the library during the access check phase. Returning a value other than \ref MODBUS_OK results in the slave reporting a \ref MODBUS_EXCEP_SLAVE_FAILURE exception to the master.

\note This functionality should not be relied upon and may be subject to change in future versions. For your own safety, please always return `MODBUS_OK` from the callback and use the `result` output argument to report any exceptions.


\subsection slave-register-callback-rw R/W queries
When `ModbusRegisterCallbackArgs::query` is either \ref MODBUS_REGQ_W or \ref MODBUS_REGQ_R the callback function is requested either to set or provide a register value accordingly.

The library guarantees that before each register is accessed a suitable access query will be made for it beforehand. However, all access queries are performed before the first R/W query, so creating cross-dependencies between registers (i.e. access rights to one register depend on the value of other register) is very likely to cause problems. It's best to disable "write multiple X" functions on such registers.

\note Return values from this callback are ignored. This functionality,
	however, should not be relied upon and may be subject to change in future releases.

An exapmple implementation of a register callback operating on registers stored in an array:
~~~c
#define REG_COUNT 16
static uint16_t registers[REG_COUNT];
static uint16_t inputRegisters[REG_COUNT];
static uint8_t coils[REG_COUNT / 8]; // Each coil corresponds to one bit
static uint8_t discreteInputs[REG_COUNT / 8]; // Each input corresponds to one bit

ModbusError myRegisterCallback(
	ModbusSlave *status,
	const ModbusRegisterCallbackArgs *args,
	uint16_t *result)
{
	// Respond to read/write access queries
	if (args->query == MODBUS_REGQ_R_CHECK || args->query == MODBUS_REGQ_W_CHECK)
	{
		// If result of a read/write access query is not 0,
		// an exception is reported by the slave
		*result = args->id < REG_COUNT ? MODBUS_EXCEP_NONE : MODBUS_EXCEP_ILLEGAL_ADDRESS;
	}
	else if (args->query == MODBUS_REGQ_R) // Read registers
	{
		switch (args->type)
		{
			case MODBUS_HOLDING_REGISTER: *result = registers[args->id]; break;
			case MODBUS_INPUT_REGISTER:   *result = inputRegsiters[args->id]; break;
			case MODBUS_COIL:             *result = modbusMaskRead(coils, args->id); break;
			case MODBUS_DISCRETE_INPUT:   *result = modbusMaskRead(discreteInputs, args->id); break;
			default: return MODBUS_ERROR_OTHER;
		}
	}
	else if (args->query == MODBUS_REGQ_W) // Write registers
	{
		switch (args->type)
		{
			case MODBUS_HOLDING_REGISTER: registers[args->id] = args->value; break;
			case MODBUS_COIL:             modbusMaskWrite(coils, args->id, args->value); break;
			default: return MODBUS_ERROR_OTHER;
		}
	}
	else
		return MODBUS_ERROR_OTHER;

	// Return MODBUS_OK on success
	return MODBUS_OK;
}
~~~

\section slave-exception-callback Slave exception callback

\note Returning error values different than MODBUS_OK from the callback will result in
	MODBUS_EXCEP_SLAVE_FAILURE exception being reported to the master. 

\todo Complete this section


\section slave-requests Request processing

After successful initialization of the slave device, it's ready to accept requests from the master. The requests
can be processed using one of the three functions: `modbusParseRequestPDU()`, `modbusParseRequestRTU()` and `modbusParseRequestTCP()`.
Calling each one of these results in an attempt to parse the request frame, a series of calls to the \ref slave-register-callback 
and optionally a response frame for the master. If the slave generates a exception frame, the \ref slave-exception-callback is called.

The response frame can be accessed using `modbusSlaveGetResponse()` and its length can be acquired using `modbusSlaveGetResponseLength()`.
These functions may not be called if `modbusIsOk()` of the returned `ModbusErrorInfo` is `false`. 

~~~c
// For Modbus RTU
ModbusErrorInfo err;
err = modbusParseRequestRTU(&slave, buffer, length);

// Handle 'serious' errors such as memory allocation problems
if (modbusGetGeneralError(&slave))
	handleSlaveError(err);

// Handle errors related to the structure of the request frame
// for example invalid CRC
if (modbusGetRequestError(&slave))
	handleRequesterrors(err);

// If the function did not return an error, the response can be accessed and is ready to be sent
// to the master. The response frame can be acquired using modbusSlaveGetResponse()
// and is modbusSlaveGetResponseLength() bytes long. Beware that response frame can be empty
// in some cases!
if (modbusIsOk(err))
	sendToMaster(modbusSlaveGetResponse(&slave), modbusSlaveGetResponseLength(&slave));

// Optionally, the response buffer can be freed now
modbusSlaveFreeResponse(&slave);
~~~

\section slave-cleanup Slave cleanup
In order to destroy the ModbusSlave structure, simply call `modbusSlaveDestroy()`:
~~~c
modbusSlaveDestroy(&slave);
~~~

\page master Master

In order to use master side functions, make sure to define `LIGHTMODBUS_MASTER` macro before
including the library. Please also see \ref building for more information.

\section master-init Master initialization
Master device state is represented by ModbusMaster structure. It must be initialized with modbusMasterInit()
before it is used:
~~~c
ModbusMaster master;
ModbusErrorInfo err;
err = modbusMasterInit(
	&master,          
	myDataCallback,                  // Callback for handling incoming data
	myExceptionCallback,             // Optional slave exception callback
	modbusMasterDefaultAllocator,    // Memory allocator for ModbusMaster
	modbusMasterDefaultFunctions,    // Set of supported functions
	modbusMasterDefaultFunctionCount // Number of supported functions
	);

// Check for errors
assert(modbusIsOk(err) && "modbusMasterInit() failed"); 
~~~


Similarly to slave, master has two callbacks - data callback and exception callback. The first is
used for processing all register data incoming to master, the latter for handling exceptions
reported by the slave. These callback are described in more detail in \ref master-data-callback and
\ref master-exception-callback.

Master also has its own memory allocator - please refer to \ref allocators for more information.

The 5th argument determines the set of functions supported by the master device. It should be
a pointer to an array of `ModbusMasterFunctionHandler` structures which associate function codes
with callbacks. The lifetime of this array must not be shorter than the lifetime of the master.
The last argument should contain length of this array.

\section master-data-callback Data callback

The data callback is a function matching `ModbusDataCallback`, used to receive data read from the slaves.

This function is called from `modbusParseResponse*()` for every received register/coil/input value. The address of the slave, index of the register, its value and function used to acquire it are provided inside `ModbusDataCallbackArgs` provided as an argument.

The data callback must return a `ModbusError`. It should always return `MODBUS_OK`.

\note Return values from this callback are ignored. This,
	however, should not be relied upon and may be subject to change in future releases.

An example of a simple data callback printing out all received data:
~~~c
/*
	Data callback for printing all incoming data
*/
ModbusError dataCallback(ModbusMaster *master, const ModbusDataCallbackArgs *args)
{
	printf(
		"Received data:\n"
		"\t from: %d\n"
		"\t  fun: %d\n"
		"\t type: %s\n"
		"\t   id: %d\n"
		"\tvalue: %d\n",
		args->address,
		args->function,
		modbusDataTypeStr(args->type), // Requires LIGHTMODBUS_DEBUG
		args->index,
		args->value
	);

	// Always return MODBUS_OK
	return MODBUS_OK;
}
~~~

\section master-exception-callback Exception callback

Master exception callback is a function matching `ModbusMasterExceptionCallback` called when an exception response frame is parsed by one of the `modbusParseResponse*()` functions.

The function is provided with address of the slave that reported this exception, function code of the function that caused it and a Modbus exception code (`ModbusExceptionCode`). It must return a `ModbusError` value, which should be `MODBUS_OK`.

\note Return values from this callback are ignored. This,
	however, should not be relied upon and may be subject to change in future releases.


An example of a simple exception callback printing out all received exceptions:
~~~c
/*
	Exception callback for printing out exceptions on master side
*/
ModbusError masterExceptionCallback(
	ModbusMaster *master,
	uint8_t address,
	uint8_t function,
	ModbusExceptionCode code)
{
	printf(
		"Received exception %s (function %d) from slave %d\n",
		modbusExceptionCodeStr(code),
		function,
		address);

	// Always return MODBUS_OK
	return MODBUS_OK;
}
~~~

\section master-requests Building requests

Master side of the library provides a set of functions for building requests. They are named
according to the pattern `modbusMasterBuildRequest*()`. Where `*` is code of the function followed
by the Modbus request format to be generated (PDU, RTU or TCP).

The functions without PDU, RTU or TCP at the end of their name are generic functions 
responsible for building the request frame and must only be used in between calls to
`modbusBeginRequest*()` and `modbusEndRequest*()`.

|Function code|Description|Functions|
|-------------|-----------|---------|
|01|Read multiple coils|`modbusBuildRequest01()`<br>`modbusBuildRequest01PDU()`<br>`modbusBuildRequest01RTU()`<br>`modbusBuildRequest01TCP()`|
|02|Read multiple discrete inputs|`modbusBuildRequest02()`<br>`modbusBuildRequest02PDU()`<br>`modbusBuildRequest02RTU()`<br>`modbusBuildRequest02TCP()`|
|03|Read multiple holding registers|`modbusBuildRequest03()`<br>`modbusBuildRequest03PDU()`<br>`modbusBuildRequest03RTU()`<br>`modbusBuildRequest03TCP()`|
|04|Read multiple input registers|`modbusBuildRequest04()`<br>`modbusBuildRequest04PDU()`<br>`modbusBuildRequest04RTU()`<br>`modbusBuildRequest04TCP()`|
|05|Write a single coil|`modbusBuildRequest05()`<br>`modbusBuildRequest05PDU()`<br>`modbusBuildRequest05RTU()`<br>`modbusBuildRequest05TCP()`|
|06|Write a single holding register|`modbusBuildRequest06()`<br>`modbusBuildRequest06PDU()`<br>`modbusBuildRequest06RTU()`<br>`modbusBuildRequest06TCP()`|
|15|Write multiple coils|`modbusBuildRequest15()`<br>`modbusBuildRequest15PDU()`<br>`modbusBuildRequest15RTU()`<br>`modbusBuildRequest15TCP()`|
|16|Write multiple holding registers|`modbusBuildRequest16()`<br>`modbusBuildRequest16PDU()`<br>`modbusBuildRequest16RTU()`<br>`modbusBuildRequest16TCP()`|
|22|Mask write register|`modbusBuildRequest22()`<br>`modbusBuildRequest22PDU()`<br>`modbusBuildRequest22RTU()`<br>`modbusBuildRequest22TCP()`|

Please see \ref master_func.impl.h for more details.

For instance, a request to read holding register 17 from slave with id 1 can be built using:
~~~c
// For Modbus RTU
ModbusErrorInfo err;
err = modbusMasterBuildRequest03RTU(&master, 1, 17, 1);
assert(modbusIsOk(err) && "modbusMasterBuildRequest03RTU() failed");
~~~

If the request has been built successfully, it can be acquired using
`modbusMasterGetRequest()`, has length of `modbusMasterGetRequestLength()` bytes and can be sent to the slave.

\section master-response Processing responses

After obtaining the response from the slave, it's time to process it. In order to do that
one of the `modbusParseResponse*()` functions can be used:
~~~c
// For Modbus RTU
ModbusErrorInfo err;
err = modbusParseResponseRTU(
	&master,
	modbusMasterGetRequest(&master),
	modbusMasterGetRequestLength(&master),
	slaveResponseData,
	slaveResponseLength);

// Handle serious errors
if (modbusGetGeneralError(err))
	handleMasterError(err);

// Handle errors relate to the structure of the request frame
if (modbusGetRequestError(err))
	handleRequestError(err);

// Handle errors related to the structure of the response frame
if (modbusGetResponseError(err))
	handleResponseError(err);

// Optionally free the request frame
modbusMasterFreeRequest(&master);
~~~

\section master-cleanup Master cleanup

When you're done using an instance of `ModbusMaster`, you can destroy it
using `modbusMasterDestroy()`.

~~~c
modbusMasterDestroy(&master);
~~~

\page error-handling Error handling
Liblightmodbus v3.0 introduces a new type for error handling - \ref ModbusErrorInfo - returned by majority
of the library functions. This new type allows to store both error type and its source (whether it was caused
by an invalid request/response frame or by an actual library error).

Previously, you would check for errors like this:
~~~c
ModbusError err = modbusDoSomething();
if (err != MODBUS_OK)
	doSomething();
~~~

In the new version, it's a bit more sophisticated:
~~~c
ModbusErrorInfo err = modbusDoSomething();

// We can check if any error happened at all
if (!modbusIsOk(err))
	doSomething();

// We can check if the library reported any general errors
// Those usually mean that the user provided an invalid argument
// or something had failed internally.
if (modbusGetGeneralError(err) != MODBUS_OK)
	handleSeriousError();

// We can check if the request frame contained an error
if (modbusGetRequestError(err) != MODBUS_OK)
	handleRequestError();

// We can also check if the response frame contained an error
if (modbusGetResponseError(err) != MODBUS_OK)
	handleResponseError();
~~~

`modbusGetGeneralError()`, `modbusGetRequestError()` and `modbusGetResponseError()` return
a `ModbusError` enum value which can be easily handled with a switch statement.

\warning You should **not** be accessing the fields of `ModbusErrorInfo` directly.
	The internals of this struct are subject to change in future versions, and
	for this exact reason the `modbusIsOk()` etc. functions exist.

\page allocators Custom allocators

Liblightmodbus allows users to define their custom functions for memory management.
This functionality is provided with mainly embedded systems in mind.

The user defined allocator is a function compatible with ModbusSlaveAllocator or ModbusMasterAllocator pointer types.

User-defined allocators must meet following requirements:
 - When `size` is 0, the memory pointed to by `*ptr` must be freed. `*ptr`
	shall then be set to `NULL`.
 - When `size` is not 0, `*ptr` should be set to point to a memory block of
	at least `size` bytes. If such block cannot be allocated, the allocator must
	return \ref MODBUS_ERROR_ALLOC and free memory block pointed to by current
	`*ptr` value. In such case `*ptr` shall be set to `NULL`.

However, certain guarantees are made by the library:
 - All allocation requests originating from a **single** ModbusMaster or
	ModbusSlave instance with identical `purpose` argument are assumed
	to refer to the same buffer. **This allows for static memory allocation
	if the allocator can distinguish between different ModbusMaster and
	ModbusSlave instances issuing the allocation requests.**

\section static-mem Static memory allocation

An example of a custom "allocator" relying only on statically allocated memory:
~~~c
// !!! This only works if the allocator is used exclusively by a single instance of ModbusMaster and ModbusSlave !!!
LIGHTMODBUS_WARN_UNUSED ModbusError modbusStaticAllocator(uint8_t **ptr, uint16_t size, ModbusBufferPurpose purpose)
{
	static uint8_t request[256];
	static uint8_t response[256];

	if (!size)
	{
		// Pretend we're freeing the buffer
		*ptr = NULL;
		return MODBUS_OK;
	}
	else
	{
		if (size > 256)
		{
			// Requested size is too big, return allocation error
			*ptr = NULL;
			return MODBUS_ERROR_ALLOC;
		}
		else
		{
			// Return a pointer to one of the static buffers depending 
			// on the declared purpose of the buffer
			*ptr = purpose == MODBUS_SLAVE_RESPONSE_BUFFER ? response : request;
			return MODBUS_OK;
		}
	}
}

// Wrapper used by slave
LIGHTMODBUS_WARN_UNUSED ModbusError modbusSlaveStaticAllocator(ModbusSlave *status, uint8_t **ptr, uint16_t size, ModbusBufferPurpose purpose)
{
	return modbusStaticAllocator(ptr, size, purpose);
}

// Wrapper used by master
LIGHTMODBUS_WARN_UNUSED ModbusError modbusMasterStaticAllocator(ModbusMaster *status, uint8_t **ptr, uint16_t size, ModbusBufferPurpose purpose)
{
	return modbusStaticAllocator(ptr, size, purpose);
}
~~~

One could also implement the buffers in `modbusSlaveStaticAllocator()` and `modbusMasterStaticAllocator()` and
distiguish between `ModbusSlave` and `ModbusMaster` instances based on the `status` argument.

\page examples Examples

Examples can be found in the [examples](https://github.com/Jacajack/liblightmodbus/tree/master/examples) directory.

\page porting Porting code from v2.0 to v3.0

The table below presents a brief overview of changes that need to be applied to existing code 
before upgrading to v3.0.

|Task|Changes|
|----|--------|
|Slave init|Update call to `modbusSlaveInit()` according to \ref slave-init|
|Master init|Update call to `modbusMasterInit()` according to \ref master-init|
|Slave cleanup|Rename `modbusSlaveEnd()` to `modbusSlaveDestroy()`|
|Master cleanup|Rename `modbusMasterEnd()` to `modbusMasterDestroy()`|
|Error handling|Use `modbusIsOk()` and `modbusGetGeneralError()`. See \ref error-handling|
|Parsing requests|Use `modbusParseRequestRTU()` instead of `modbusParseRequest()`. Provide the frame as an argument.|
|Register callback|Slave register callback now takes arguments in a struct. See \ref slave-register-callback|
|Register/coil arrays|Write a register callback accesing your own array instead. See \ref slave-register-callback|
|Accessing slave's response|Use modbusSlaveGetResponse() and modbusSlaveGetResponseLength() instead of accessing directly accessing the fields in ModbusSlave|
|Building requests|Use `modbusBuildRequest*RTU()` instead of `modbusBuildRequest*()`|
|Accessing master's request|Use modbusMasterGetRequest() and modbusMasterGetRequestLength() instead of accessing directly accessing the fields in ModbusMaster|
|Parsing responses|Use `modbusParseResponseRTU()` instead of `modbusParseResponse()`. Provide both request and response frames as arguments|
|Receiving data|Implement a data callback to receive the data on the master end - see \ref master-data-callback|
|Endiannes operations|Use modbusRLE(), modbusRBE(), modbusWLE() and modbusWBE() instead|
|Mask read/write|modbusMaskRead() and modbusMaskWrite() no longer provide bounds checking|
|Static memory allocation|Implement a custom static memory allocator - see \ref static-mem|

\cond DOXYGEN_EXCLUDE
\section endiannnes Endianness operations
`modbusSwapEndian()` and `modbusMatchEndian()` were dropped in favor of less ambiguous and safe
functions for reading 16-bit integer words:
 - `modbusRLE()` - read a 16-bit little-endian word
 - `modbusRBE()` - read a 16-bit big-endian word
 - `modbusWLE()` - write a 16-bit little-endian word
 - `modbusWBE()` - write a 16-bit big-endian word

Conveniently, pointers provided to those functions don't need to be aligned, because
reading is done byte-after-byte manner for safety and portability (`__attribute__((packed))` is not so great. It's completely useless on XC16 compilers).
\endcond

*/
