/**
\mainpage liblightmodbus - a lightweight, header-only, cross-platform Modbus RTU/TCP library



This is a reference manual for the liblightmodbus library.

## About this release

Version v3.0 brings the most changes in the history of liblightmodbus.


## Getting started
 - \ref building
 - \ref basic-usage
 - \ref porting
 - \ref callbacks
 - \ref allocators

\page building Building and integrating liblightmodbus

Since the version v3.0, liblightmodbus is a header-only library. This decision was
made due to large number of questions and problems regarding compilation on different platforms.
As it turns out, CMake doesn't go very well with embedded projects.

In order to integrate liblightmodbus with your project you need to add
`liblightmodbus/include` to you include paths. If you're using CMake you might 
do that automatically by including `lightmodbus` package.

In your source code you should be using `#include <lightmodbus/lightmodbus.h>` to include the library.
The library can be configured by defining certain macros before including that file:
 - `LIGHTMODBUS_IMPL` - include implementation
 - `LIGHTMODBUS_SLAVE` - include slave part of the library
 - `LIGHTMODBUS_MASTER` - include master part of the library
 - `LIGHTMODBUS_FULL` - include both slave and master modules and all of their functions
 - `LIGHTMODBUS_DEBUG` - include some debugging utilites
 - Specific master/slave functions can be included by defining macros like `LIGHTMODBUS_F01M` or `LIGHTMODBUS_F22S`.

Each time `lightmodbus.h` is included, the set of defined configuration macros must be the same
(except from `LIGHTMODBUS_IMPL` which should only be used **once**).

Moreover, it's very important that you include implementation of the library functions (`LIGHTMODBUS_IMPL`) in
**exactly one** place in your codebase. It may be a good idea to create a source file dedicated specifically for
including implementation of liblightmodbus. For instance, you may want to create `lightmodbus-impl.c` containing:
~~~c
#include "my-consistent-liblightmodbus-config-macros.h"
#define LIGHTMODBUS_IMPL
#include <lightmodbus/lightmodbus.h>
~~~

\page basic-usage Basic usage

## Slave code

## Master

## Error handling

\page porting Porting exisiting code to liblightmodbus v3.0

## Initialization and cleanup


## Error handling
Liblightmodbus v3.0 introduces a new type for error handling - \ref ModbusErrorInfo - returned by majority
of the library functions. This new type allows to store both error type and its source (whether it was caused
by an invalid request/response frame or by an actual library error).

Previously, you would check for errors like this:
~~~c
ModbusError err = modbusDoSomething();
if (err != MODBUS_OK)
	doSomething();
~~~

In the new version, it's a bit more sophisticated:
~~~c
ModbusErrorInfo err = modbusDoSomething();

// We can check if any error happened at all
if (!modbusIsOk(err))
	doSomething();

// We can check if the library reported any general errors
// Those usually mean that the user provided an invalid argument
// or something had failed internally.
if (modbusGetGeneralError(err) != MODBUS_OK)
	handleSeriousError();

// We can check if the request frame contained an error
if (modbusGetRequestError(err) != MODBUS_OK)
	handleRequestError();

// We can also check if the response frame contained an error
if (modbusGetResponseError(err) != MODBUS_OK)
	handleResponseError();
~~~

`modbusGetGeneralError()`, `modbusGetRequestError()` and `modbusGetResponseError()` return
a `ModbusError` enum value which can be easily handled with a switch statement.

## Slave code

## Master code

## Static memory

Static memory allocation in v3.0 can be easily achieved by writing a custom memory allocator. Please refer to \ref allocators for more information.

## modbusMaskRead() and modbusMaskWrite()

The `modbusMaskRead()` and `modbusMaskWrite()` work exactly like in the previous versions, but no
longer provide bounds checking.

## modbusSwapEndian() and modbusMatchEndian()

`modbusSwapEndian()` and `modbusMatchEndian()` were dropped in favor of less ambiguous and safe
functions for reading 16-bit integer words:
 - `modbusRLE()` - read a 16-bit little-endian word
 - `modbusRBE()` - read a 16-bit big-endian word
 - `modbusWLE()` - write a 16-bit little-endian word
 - `modbusWBE()` - write a 16-bit big-endian word

Conveniently, pointers provided to those functions don't need to be aligned, because
reading is done byte-after-byte manner for safety and portability (`__attribute__((packed))` is not so great. It's completely useless on XC16 compilers).

\page callbacks User-defined callback functions




\page allocators User-defined allocators

Liblightmodbus allows users to define their custom functions for memory management.
This functionality is provided with mainly embedded systems in mind.

The user defined allocator is a function in form:
~~~{.c}
ModbusError allocator(uint8_t **ptr, uint16_t size, ModbusBufferPurpose purpose);
~~~

User-defined allocators must meet following requirements:
 - When `size` is 0, the memory pointed to by `*ptr` must be freed. `*ptr`
	shall then be set to NULL.
 - When `size` is not 0, `*ptr` should be set to point to a memory block of
	`size` bytes. If such block cannot be allocated, the allocator must
	return \ref MODBUS_ERROR_ALLOC and free memory block pointed to by current
	`*ptr` value.

However, certain guarantees are made by the library:
 - All allocation requests originating from a **single** ModbusMaster or
	ModbusSlave instance with identical `purpose` argument are assumed
	to refer to the same buffer. **This allows for static memory allocation
	if the allocator can distinguish between different ModbusMaster and
	ModbusSlave instances issuing the requests**

## Static memory allocation

An example of a custom "allocator" relying only on statically allocated memory:
~~~c
// !!! This only works if the allocator is used exclusively by a single instance of ModbusMaster and ModbusSlave !!!
LIGHTMODBUS_WARN_UNUSED ModbusError modbusStaticAllocator(uint8_t **ptr, uint16_t size, ModbusBufferPurpose purpose)
{
	static uint8_t request[256];
	static uint8_t response[256];

	if (!size)
	{
		// Pretend we're freeing the buffer
		*ptr = NULL;
		return MODBUS_OK;
	}
	else
	{
		if (size > 256)
		{
			// Requested size is too big, return allocation error
			*ptr = NULL;
			return MODBUS_ERROR_ALLOC;
		}
		else
		{
			// Return a pointer to one of the static buffers depending 
			// on the declared purpose of the buffer
			*ptr = purpose == MODBUS_SLAVE_RESPONSE_BUFFER ? response : request;
			return MODBUS_OK;
		}
	}
}

// Wrapper used by slave
LIGHTMODBUS_WARN_UNUSED ModbusError modbusSlaveStaticAllocator(ModbusSlave *status, uint8_t **ptr, uint16_t size, ModbusBufferPurpose purpose)
{
	return modbusStaticAllocator(ptr, size, purpose);
}

// Wrapper used by master
LIGHTMODBUS_WARN_UNUSED ModbusError modbusMasterStaticAllocator(ModbusMaster *status, uint8_t **ptr, uint16_t size, ModbusBufferPurpose purpose)
{
	return modbusStaticAllocator(ptr, size, purpose);
}
~~~

One could also implement the buffers in `modbusSlaveStaticAllocator()` and `modbusMasterStaticAllocator()` and
distriguish between `ModbusSlave` and `ModbusMaster` instances based on the `status` argument.

*/
